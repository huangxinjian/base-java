package container.map;

/**
 * @Author: huangxinjian
 * @Description:  二叉树和红黑二叉树
 * @Date: Created in 9:39 2019/2/25
 * @Modified By:
 */
public class BinaryTreeAndRedBlackTree {


    /*

        普通二叉树：

            二叉树是由一个节点及两颗互不相交、分别称为这个根节点的左子树和右子树的二叉树组成。例如下面5种情况：


                   Ø            O                O              O               O
                                                /                \             / \
                                               O                  O           O   O
                  (a)          (b)              (c)           （d）            (e)

            其中   a:  为空树
                   b:  为仅有一个节点的二叉树
                   c:  是仅有左子树而右子树为空的二叉树
                   d:  是仅有右子树而左子树为空的二叉树
                   e:  是左子树和右子树均非空的二叉树

            注意： c、d是两颗不同的二叉树，因为二叉树中左子树和右子树是严格区别开的，不可颠倒




        排序二叉树：

            特性：
              （1） 左子树上所有节点的值均小于它的根节点的值
              （2） 右子树上所有节点的值均大于它的根节点的值

            比如：我们要将数据【14,12,23,4,16,13, 8,,3】存储到排序二叉树中，如下图所示：

                                14
                               /  \
                            12     23
                           /  \   /
                          4   13 16
                         / \
                        3  8
                 排序二叉树本身实现了排序功能，可以快速检索。
                 但如果插入的节点集本身就是有序的，要么从小到大排序，要么从大到小排序。
                    那么最后得到的二叉树将变成普通的链表，其检索效率就会很差

          比如上面的数据【14,12,23,4,16,13, 8,,3】，
          我们先进行排序变成：【3,4,8,12,13,14,16,23】，然后存储到排序二叉树中，显然就变成了链表，如下图所示：
                            3
                             \
                              4
                               \
                                8
                                 \
                                 12
                                  \
                                   13
                                    \
                                    14
                                      \
                                      16
                                       \
                                        23

           平衡二叉树：

                为了避免出现上面的一边倒的存储，科学家们提出了平衡二叉树

              特性:
                (1)  在平衡二叉树中任何两个节点的两个子树的高度最大差别为1，所以它也被称为高度二叉树
                   增加和删除节点可能需要通过一次或多次树旋转来重新平衡这个树。
                (2)  节点的平衡因子是它的左子树的高度减去它的右子树的高度(有时相反),带有平衡因子 0、1、-1的二叉树
                   通常被认为是平衡的，带有平衡因子 2、-2的节点被认为是不平衡的，并需要重新平衡这个树

            比如，我们存储排好序的数据【3,4,8,12,13,14,16,23】，增加节点如果出现不平衡，
            则通过节点的左旋或右旋，重新平衡树结构，最终平衡二叉树如下图所示：

                                14                                     12
                               /  \                                   /  \
                            12     23                                4    14
                           /  \   /                                 / \   / \
                          4   13 16                                3  8  13  16
                         / \                                                  \
                        3  8                                                  23
                         （排序二叉树）                              (平衡二叉树)
            平衡二叉树追求绝对平衡，实现起来比较麻烦，每次插入新节点需要做的旋转操作次数不能预知。


           红黑二叉树：
                红黑二叉树又称为红黑树，它首先是一颗二叉树，同时也是一颗自平衡的排序二叉树
              红黑树在原先的排序二叉树中又增加了如下几个要求：
                1. 每个节点要么是红色，要么是黑色
                2. 根节点永远是黑色
                3. 所有的叶节点都是空节点（即为null），并且是黑色的
                4. 每个红色节点的两个子节点都是黑色的（从每个节点到根的路径上不会出现两个连续的红色节点）
                5. 从任一个节点到其子树中每个叶子节点的路径上都包含相同数量的黑色节点

                这些约束强化了红黑树的关键性质： 从根到叶子的最长的可能路径不多于最短的的可能路径的两倍长



          红黑树是一个更高效的检索二叉树，JDK 提供的集合类 TreeMap、TreeSet 本身就是一个红黑树的实现


           红黑树的基本操作：插入、删除、左旋、右旋、着色。 每插入或者删除一个节点，
           可能会导致树不在符合红黑树的特征，需要进行修复，进行 “左旋、右旋、着色”操作，使树继续保持红黑树的特性。
     */
}
