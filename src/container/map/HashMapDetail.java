package container.map;

import java.util.HashMap;
import java.util.Map;

/**
 * @Author: huangxinjian
 * @Description:
 * @Date: Created in 18:23 2019/2/19
 * @Modified By:
 */
public class HashMapDetail {

    /*

            我们知道，数组的特点是：占用空间连续，寻址容易，查询效率高，但是，增加元素和删除元素效率低
                      链表的特点是：占用空间不连续，寻址困难，查询效率低，但是 增删效率高

             因此，我们如果结合数组和链表的优点（查询高，增删快），会不会有更好的数据结构呢？
             答案就是 哈希表，哈希表的本质就是 “数组+链表”


            而 HashMap 底层实现采用的就是哈希表，即“数组+链表”，

            通过查看源代码，我们可以看到，HashMap中的核心存储对象是:  Node<K,V>[] table; 这个数组也称为 位桶数组

            一个节点数组 Node[] ，这就是我们hashMap的核心，查看Node的源代码，我们可以看到由以下部分组成：

                     final int hash;   // 哈希值
                     final K key;       //  key对象
                     V value;           // value 对象
                     Node<K,V> next;    // 下一个节点对象

             可以看出，每个 Node 对象其实就是一个 单向链表结构，下图可以表示出它的存储结构：
        ———————————————         ———————————————         ———————————————
       | hash | key | value | next |   --->  | hash | key | value | next |   --->   | hash | key | value | next |
        ———————————————         ———————————————          ———————————————

            然后，我们画出 Node[] 数组的结构(这也是HashMap的结构)：

                                                Node[] 数组
        ————————————————————————————————————————————————————————————
        |       节点（我们存储的数据）                        节点                                                        |
        |   ———————————————         ———————————————         ———————————————     |
 索引0  |   | hash | key | value | next |   --->  | hash | key | value | next |   --->   | hash | key | value | next |   |
        |   ———————————————         ———————————————          ———————————————    |
        |                                                                                                                |
        ————————————————————————————————————————————————————————————

        ————————————————————————————————————————————————————————————
        |       节点（我们存储的数据）                                                                                   |
        |   ———————————————                                                                                |
 索引1  |   | hash | key | value | next |                                                                                |
        |   ———————————————                                                                                |
        |                                                                                                                |
        ————————————————————————————————————————————————————————————
                                                          。
                                                          。
                                                          。
                                                          。
        直到 索引15，因为HashMap的默认初始化长度就是16，

        类似如图这样的结构，就是 table 数组中某个索引对应的 链表，可以这么说，HashMap的核心是数组，数组里面的每一项存储的是一个链表




        下面我们介绍一下HashMap的存储数据的过程，即 put(key,value) 方法:

                明白了HashMap的基本结构后，我们继续深入学习HashMap如何存储数据。此处的核心是如何产生Hash值，
                    因为Hash值就对应了数组的索引，相同hash值会存放到同一个索引下，因此该值用来对应数组的存储位置。

            （1） 获得key对象的hashcode
                    即首先调用 key对象的 hashCode() 方法，获得hashcode
            （2） 根据hashcode计算出hash值，要求范围在 [0,数组长度-1]
                    hashcode是一个整数，我们需要将它转化成 [0,数组长度-1] 的范围，
                    要求转化后的hash值尽量均匀地分布在[0,数组长度-1]这个区间，减少 “hash冲突”
               (2.1)  一种极端简单和低下的办法是：
                       hash值 = hashcode / hashcode

                       也就是说，hash值总是1，这也意味着，所有的键值对对象都会存储在索引为1的位置，这样就会形成一个非常长的链表，
                    相当于每存储一个对象都会发生 ”hash冲突“，而且这样 hashMap 也退化成一个 单向链表了。

              （2.2） 另一种简单和常用的办法是：
                      hash值 = hashcode % 数组长度  （对任何数求余，得到的结果都会在 [0,这个数-1]的区间中，因为余数必须小于除数）

                      这种算法可以使得 hash值 均匀的分布在 [0,数组长度-1] 这个区间中。早期的hashTable就是采用这种算法。
                    但是这种算法使用了除法，效率低下。JDK后来改进了算法，使用了 “位运算”，而且首先约定数组长度必须为 “2的整数幂”
                    这样采用位运算即可实现取余的效果： hash值= hashcode & (数组长度 - 1)

                    下面的代码就做了一个简单的测试，得到的结果是一模一样的

             事实上，为了获得更好的散列效果，JDK对hashcode进行了两次散列处理(核心目标就是为了分布更散更均匀)

           （3）生成 Node 节点对象（真正存放我们数据的对象）
                  在我们获取了hash值后，我们就得到了我们的数组索引，因此我们下一步就是生成存放我们数据的 Node 节点对象，
               一个 Node 节点对象如上面介绍所说，包含了：key对象、value对象、hash值、指向下一个Node对象的引用。
               我们现在算出了hash值，下一个Node对象的引用为null

           （4）将 Node 对象放到 table 数组中
                  如果本Node节点对象对应的索引位置还没有放Node对象，则直接将Node对象存储进数组
                  如果对应索引位置已经有Node对象，则将已有的Node对象的next引用指向本Node对象，形成链表


         总结如上过程:
              当添加一个元素（key-value）时，首先计算 key对象的hashcode 值，以此确定插入到数组中的位置，但是可能该位置
          已经存在同一hash值的 Node对象了，这时就添加到同一 hash值 的对象的后面，形成单向链表，同一个链表上的hash值是相同的，
          都代表了数组的索引，所以说数组存放的是链表，JDK8中，当链表长度大于8的时候，链表就转换成红黑树，这样就可以大大提高查询效率


      下面我们介绍一下HashMap的取数据的过程，即 get(key) 方法:
            我们需要通过 key对象 获取到 “键值对” 对象，进而返回 value对象，明白了存储过程，取数据就比较简单了，步骤如下:
            (1) 根据 key对象的hashcode，计算出索引的位置
           （2）在链表上挨个比较 key对象，调用 equals() 方法，将 key对象和链表上的所有节点的key对象进行比较，直到碰到返回true的节点对象为止
           （3）返回equals()为true的节点对象的value对象。

            java中规定，两个内容相同(equals()为true)的对象必须具有相同的hashcode。因为如果equals为true而两个对象的hashcode不同
                在整个存储结构中就发生了悖论

       下面我们介绍一下HashMap的扩容问题:

            HashMap的位桶数组，初始化默认长度为16，实际使用时，大小是可变的，如果位桶数组中的元素达到了(0.75*数组 length)
          就重新调整数组大小变为原来 2倍大小。

          扩容十分耗时，因为扩容的本质其实是定义更大的一个新数组，并将旧数组的数据挨个拷贝到新数组中


      下面我们介绍一下 ：JDK8将链表在大于8情况下变为红黑二叉树

            JDK8中，HashMap在存储一个元素时，当对应链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率。
         下一节，我们简单介绍一个二叉树。同时，也便于大家理解TreeMap的底层结构。


     */

    public static void main(String[] args) {
        int h = 25860399;
        int length = 16;//length为2的整数次幂,则h&(length-1)相当于对length取模
        myHash(h, length);




    }
    /**
     *
     * 测试 hash值，使用 位运算和 求余的区别
     * @param h  任意整数
     * @param length 长度必须为2的整数幂
     * @return
     */
    public static  int myHash(int h,int length){
        System.out.println(h&(length-1));
        //length为2的整数幂情况下，和取余的值一样
        System.out.println(h%length);//取余数
        return h&(length-1);
    }
}
